{
  "version": 3,
  "sources": ["../src/index.ts", "../src/function/get-action-input.ts", "../src/function/get-github-input.ts", "../src/function/create-tag.ts", "../src/function/get-package-version.ts", "../src/function/install-packages.ts", "../src/function/promise-action-exec.ts"],
  "sourcesContent": ["import { info, setFailed, setOutput } from '@actions/core';\nimport { getActionInput } from './function/get-action-input';\nimport { getGithubInput } from './function/get-github-input';\nimport { createTag } from './function/create-tag';\nimport {\n  getPackageInfo,\n  getPackageScope,\n  getPackageVersion,\n} from './function/get-package-version';\nimport { exec } from '@actions/exec';\nimport { installPackages } from './function/install-packages';\nimport { writeFileSync } from 'fs';\n\n//IIFE ->  Immediately-invoked Function Expression\n(async () => {\n  try {\n    const mergedInput = { ...getActionInput(), ...getGithubInput() };\n\n    let packageInfo = await getPackageInfo(mergedInput);\n    let packageVersion = await getPackageVersion(packageInfo);\n    let packageScope = await getPackageScope(packageInfo);\n\n    setOutput('currentVersion', packageVersion.currentPackageVersion);\n\n    if (\n      packageVersion.publishedVersions.find(\n        (v) => packageVersion.currentPackageVersion === v\n      )\n    ) {\n      info(`Package already published ${packageVersion.currentPackageVersion}`);\n      setOutput('published', false);\n      return;\n    }\n\n    await installPackages(mergedInput);\n\n    const lines = [\n      `//${mergedInput.registry.replace(/^https?:\\/\\//, '')}:_authToken=${\n        mergedInput.authToken\n      }`,\n      `_auth=${mergedInput.authToken}`,\n      'email=bot@github-action-npm-publish.com',\n      'always-auth=true',\n      `registry=${mergedInput.registry}`,\n      ,\n    ];\n\n    if (packageScope !== null) {\n      `${packageScope}:registry=${mergedInput.registry}`;\n    }\n\n    writeFileSync('/home/runner/.npmrc', lines.join('\\n'));\n\n    await exec(`npm publish ${mergedInput.projectBuildDir} --access public`);\n    setOutput('published', true);\n\n    if (mergedInput.createTag) {\n      await createTag(mergedInput, packageVersion.currentPackageVersion);\n    }\n  } catch (error) {\n    if (typeof error === 'string') {\n      setFailed(error);\n    } else if (error instanceof Error) {\n      setFailed(error);\n    }\n  }\n})();\n", "import { getInput } from '@actions/core';\n\nexport interface IActionInput {\n  projectBuildDir: string;\n  createTag: boolean;\n  installBuildPackages: boolean;\n  authToken: string;\n  registry: string;\n}\n\nexport const getActionInput = (): IActionInput => {\n  const missing: Array<string> = [];\n\n  const authToken = getInput('auth_token');\n\n  if (!authToken) {\n    missing.push('auth_token');\n  }\n\n  if (missing.length > 0) {\n    throw new Error(`Missing input ${missing.join(' ')}`);\n  }\n\n  return {\n    authToken,\n    createTag: getInput('create_tag') === 'true',\n    projectBuildDir: getInput('project_build_dir') || 'dist',\n    registry: getInput('registry') || 'https://registry.npmjs.org/',\n    installBuildPackages: getInput('install_build_packages') === 'true',\n  };\n};\n", "export interface IGithubEnvironment {\n    ref: string;\n    sha: string;\n    repository: string;\n    token: string;\n}\n\n/**\n * Get Github environment\n */\nexport const getGithubInput = (): IGithubEnvironment => {\n    const missing: Array<string> = [];\n    const {GITHUB_REF, GITHUB_SHA, GITHUB_REPOSITORY, GITHUB_TOKEN} = process.env;\n    if (!GITHUB_REF) {\n        missing.push(\"GITHUB_REF\");\n    }\n    if (!GITHUB_SHA) {\n        missing.push(\"GITHUB_SHA\");\n    }\n    if (!GITHUB_REPOSITORY) {\n        missing.push(\"GITHUB_REPOSITORY\");\n    }\n    if (!GITHUB_TOKEN) {\n        missing.push(\"GITHUB_TOKEN\");\n    }\n    if (missing.length > 0) {\n        throw new Error(`Missing env ${missing.join(' ')}`);\n    }\n\n    return {\n        ref: GITHUB_REF as string,\n        sha: GITHUB_SHA as string,\n        repository: GITHUB_REPOSITORY as string,\n        token: GITHUB_TOKEN as string,\n    }\n}\n\n", "import { context, getOctokit } from '@actions/github';\nimport { debug } from '@actions/core';\nimport { IGithubEnvironment } from './get-github-input';\nimport { IActionInput } from './get-action-input';\n\nexport const createTag = async (\n  mergedInput: IGithubEnvironment & IActionInput,\n  currentTag: string\n) => {\n  const gitClient = getOctokit(mergedInput.token).rest.git;\n\n  debug(`Pushing new tag to the repo`);\n  const tagCreateResponse = await gitClient.createTag({\n    ...context.repo,\n    tag: currentTag,\n    message: `Released version ${currentTag}`,\n    object: mergedInput.sha,\n    type: 'commit',\n  });\n\n  const tagSha = tagCreateResponse.data.sha;\n\n  debug(`Pushing new tag to the repo`);\n  await gitClient.createRef({\n    ...context.repo,\n    ref: `refs/tags/${currentTag}`,\n    sha: tagSha,\n  });\n};\n", "import fetch from 'node-fetch';\nimport { join } from 'path';\nimport { existsSync, readFileSync } from 'fs';\nimport { IActionInput } from './get-action-input';\nimport { IGithubEnvironment } from './get-github-input';\n\ninterface PackageInfo {\n  name: string;\n  version: string;\n}\nexport interface PackageVersion {\n  currentPackageVersion: string;\n  publishedVersions: Array<string>;\n}\n\nexport const download = async <Response>(\n  url: string,\n  settings = { method: 'GET' }\n) => {\n  const response = await fetch(url, settings);\n  return (await response.json()) as Promise<Response>;\n};\n\nexport const getPackageInfo = async (\n  mergedInput: IActionInput & IGithubEnvironment\n): Promise<PackageInfo> => {\n  const packageJsonPath = join(mergedInput.projectBuildDir, `package.json`);\n\n  if (!existsSync(packageJsonPath)) {\n    throw new Error(\n      `Missing package json in project build directory (${packageJsonPath}).`\n    );\n  }\n\n  return JSON.parse(\n    readFileSync(packageJsonPath).toString('utf8')\n  ) as PackageInfo;\n};\n\nexport const getPackageVersion = async (\n  packageInfo: PackageInfo\n): Promise<PackageVersion> => {\n  const publishedVersions: Array<string> = await download<{ versions: {} }>(\n    `https://registry.npmjs.org/${packageInfo.name}`\n  )\n    .then((value) => value.versions || {})\n    .then((versions) => Object.keys(versions));\n\n  return {\n    currentPackageVersion: packageInfo.version,\n    publishedVersions,\n  };\n};\n\nexport const getPackageScope = (packageInfo: PackageInfo): string | null => {\n  const { name: packageName } = packageInfo;\n  if (packageName.startsWith('@')) {\n    const endIndex = packageName.indexOf('/', 1);\n    return endIndex !== -1 ? packageName.slice(0, endIndex) : null;\n  }\n  return null;\n};\n", "import {IGithubEnvironment} from \"./get-github-input\";\nimport {IActionInput} from \"./get-action-input\";\nimport {join} from \"path\";\nimport {existsSync} from \"fs\";\nimport {info} from \"@actions/core\";\nimport {exec} from \"./promise-action-exec\";\n\nexport const installPackages = async (mergedInput: IGithubEnvironment & IActionInput) => {\n\n    if (mergedInput.installBuildPackages) {\n        if (existsSync(join(mergedInput.projectBuildDir, \"package-lock.json\"))) {\n            info(\"Skip: already installed via npm\")\n            return;\n        }\n\n        if (existsSync(join(mergedInput.projectBuildDir, \"yarn.lock\"))) {\n            info(\"Skip: already installed via yarn\")\n            return;\n        }\n\n        await exec(`npm --prefix ${mergedInput.projectBuildDir} install --production`);\n    }\n}", "import { exec as _exec } from '@actions/exec';\n\nexport interface IExecResponse {\n  code: number;\n  stdout: string;\n  stderr: string;\n  error?: any;\n}\n\n/**\n * execute command over github actions\n * @param command the command to execute\n */\nexport const exec = async (command: string): Promise<IExecResponse> => {\n  let stdout = '';\n  let stderr = '';\n  try {\n    return {\n      code: await _exec(command, undefined, {\n        listeners: {\n          stdout: (data: Buffer) => {\n            stdout += data.toString();\n          },\n          stderr: (data: Buffer) => {\n            stderr += data.toString();\n          },\n        },\n      }),\n      stdout,\n      stderr,\n    };\n  } catch (err) {\n    throw new Error(`Error in command '${command}', ${err} `);\n  }\n};\n"],
  "mappings": "wdAAA,IAAAA,EAA2C,yBCA3C,IAAAC,EAAyB,yBAUZC,EAAiB,IAAoB,CAChD,IAAMC,EAAyB,CAAC,EAE1BC,KAAY,YAAS,YAAY,EAMvC,GAJKA,GACHD,EAAQ,KAAK,YAAY,EAGvBA,EAAQ,OAAS,EACnB,MAAM,IAAI,MAAM,iBAAiBA,EAAQ,KAAK,GAAG,GAAG,EAGtD,MAAO,CACL,UAAAC,EACA,aAAW,YAAS,YAAY,IAAM,OACtC,mBAAiB,YAAS,mBAAmB,GAAK,OAClD,YAAU,YAAS,UAAU,GAAK,8BAClC,wBAAsB,YAAS,wBAAwB,IAAM,MAC/D,CACF,ECpBO,IAAMC,EAAiB,IAA0B,CACpD,IAAMC,EAAyB,CAAC,EAC1B,CAAC,WAAAC,EAAY,WAAAC,EAAY,kBAAAC,EAAmB,aAAAC,CAAY,EAAI,QAAQ,IAa1E,GAZKH,GACDD,EAAQ,KAAK,YAAY,EAExBE,GACDF,EAAQ,KAAK,YAAY,EAExBG,GACDH,EAAQ,KAAK,mBAAmB,EAE/BI,GACDJ,EAAQ,KAAK,cAAc,EAE3BA,EAAQ,OAAS,EACjB,MAAM,IAAI,MAAM,eAAeA,EAAQ,KAAK,GAAG,GAAG,EAGtD,MAAO,CACH,IAAKC,EACL,IAAKC,EACL,WAAYC,EACZ,MAAOC,CACX,CACJ,ECnCA,IAAAC,EAAoC,2BACpCC,EAAsB,yBAITC,EAAY,MACvBC,EACAC,IACG,CACH,IAAMC,KAAY,cAAWF,EAAY,KAAK,EAAE,KAAK,OAErD,SAAM,6BAA6B,EASnC,IAAMG,GARoB,MAAMD,EAAU,UAAU,CAClD,GAAG,UAAQ,KACX,IAAKD,EACL,QAAS,oBAAoBA,IAC7B,OAAQD,EAAY,IACpB,KAAM,QACR,CAAC,GAEgC,KAAK,OAEtC,SAAM,6BAA6B,EACnC,MAAME,EAAU,UAAU,CACxB,GAAG,UAAQ,KACX,IAAK,aAAaD,IAClB,IAAKE,CACP,CAAC,CACH,EC5BA,IAAAC,EAAkB,yBAClBC,EAAqB,gBACrBC,EAAyC,cAa5BC,EAAW,MACtBC,EACAC,EAAW,CAAE,OAAQ,KAAM,IAGnB,MADS,QAAM,EAAAC,SAAMF,EAAKC,CAAQ,GACnB,KAAK,EAGjBE,EAAiB,MAC5BC,GACyB,CACzB,IAAMC,KAAkB,QAAKD,EAAY,gBAAiB,cAAc,EAExE,GAAI,IAAC,cAAWC,CAAe,EAC7B,MAAM,IAAI,MACR,oDAAoDA,KACtD,EAGF,OAAO,KAAK,SACV,gBAAaA,CAAe,EAAE,SAAS,MAAM,CAC/C,CACF,EAEaC,EAAoB,MAC/BC,GAC4B,CAC5B,IAAMC,EAAmC,MAAMT,EAC7C,8BAA8BQ,EAAY,MAC5C,EACG,KAAME,GAAUA,EAAM,UAAY,CAAC,CAAC,EACpC,KAAMC,GAAa,OAAO,KAAKA,CAAQ,CAAC,EAE3C,MAAO,CACL,sBAAuBH,EAAY,QACnC,kBAAAC,CACF,CACF,EAEaG,EAAmBJ,GAA4C,CAC1E,GAAM,CAAE,KAAMK,CAAY,EAAIL,EAC9B,GAAIK,EAAY,WAAW,GAAG,EAAG,CAC/B,IAAMC,EAAWD,EAAY,QAAQ,IAAK,CAAC,EAC3C,OAAOC,IAAa,GAAKD,EAAY,MAAM,EAAGC,CAAQ,EAAI,KAE5D,OAAO,IACT,EJpDA,IAAAC,EAAqB,yBKPrB,IAAAC,EAAmB,gBACnBC,EAAyB,cACzBC,EAAmB,yBCJnB,IAAAC,EAA8B,yBAajBC,EAAO,MAAOC,GAA4C,CACrE,IAAIC,EAAS,GACTC,EAAS,GACb,GAAI,CACF,MAAO,CACL,KAAM,QAAM,EAAAC,MAAMH,EAAS,OAAW,CACpC,UAAW,CACT,OAASI,GAAiB,CACxBH,GAAUG,EAAK,SAAS,CAC1B,EACA,OAASA,GAAiB,CACxBF,GAAUE,EAAK,SAAS,CAC1B,CACF,CACF,CAAC,EACD,OAAAH,EACA,OAAAC,CACF,CACF,OAASG,EAAP,CACA,MAAM,IAAI,MAAM,qBAAqBL,OAAaK,IAAM,CAC1D,CACF,ED3BO,IAAMC,EAAkB,MAAOC,GAAmD,CAErF,GAAIA,EAAY,qBAAsB,CAClC,MAAI,iBAAW,QAAKA,EAAY,gBAAiB,mBAAmB,CAAC,EAAG,IACpE,QAAK,iCAAiC,EACtC,OAGJ,MAAI,iBAAW,QAAKA,EAAY,gBAAiB,WAAW,CAAC,EAAG,IAC5D,QAAK,kCAAkC,EACvC,OAGJ,MAAMC,EAAK,gBAAgBD,EAAY,sCAAsC,EAErF,ELXA,IAAAE,EAA8B,eAG7B,SAAY,CACX,GAAI,CACF,IAAMC,EAAc,CAAE,GAAGC,EAAe,EAAG,GAAGC,EAAe,CAAE,EAE3DC,EAAc,MAAMC,EAAeJ,CAAW,EAC9CK,EAAiB,MAAMC,EAAkBH,CAAW,EACpDI,EAAe,MAAMC,EAAgBL,CAAW,EAIpD,MAFA,aAAU,iBAAkBE,EAAe,qBAAqB,EAG9DA,EAAe,kBAAkB,KAC9BI,GAAMJ,EAAe,wBAA0BI,CAClD,EACA,IACA,QAAK,6BAA6BJ,EAAe,uBAAuB,KACxE,aAAU,YAAa,EAAK,EAC5B,OAGF,MAAMK,EAAgBV,CAAW,EAEjC,IAAMW,EAAQ,CACZ,KAAKX,EAAY,SAAS,QAAQ,eAAgB,EAAE,gBAClDA,EAAY,YAEd,SAASA,EAAY,YACrB,0CACA,mBACA,YAAYA,EAAY,WACxB,CACF,EAEIO,IAAiB,MAChB,GAAAA,IAAyBP,EAAY,cAG1C,iBAAc,sBAAuBW,EAAM,KAAK;AAAA,CAAI,CAAC,EAErD,QAAM,QAAK,eAAeX,EAAY,iCAAiC,KACvE,aAAU,YAAa,EAAI,EAEvBA,EAAY,WACd,MAAMY,EAAUZ,EAAaK,EAAe,qBAAqB,CAErE,OAASQ,EAAP,CACI,OAAOA,GAAU,YACnB,aAAUA,CAAK,EACNA,aAAiB,UAC1B,aAAUA,CAAK,CAEnB,CACF,GAAG",
  "names": ["import_core", "import_core", "getActionInput", "missing", "authToken", "getGithubInput", "missing", "GITHUB_REF", "GITHUB_SHA", "GITHUB_REPOSITORY", "GITHUB_TOKEN", "import_github", "import_core", "createTag", "mergedInput", "currentTag", "gitClient", "tagSha", "import_node_fetch", "import_path", "import_fs", "download", "url", "settings", "fetch", "getPackageInfo", "mergedInput", "packageJsonPath", "getPackageVersion", "packageInfo", "publishedVersions", "value", "versions", "getPackageScope", "packageName", "endIndex", "import_exec", "import_path", "import_fs", "import_core", "import_exec", "exec", "command", "stdout", "stderr", "_exec", "data", "err", "installPackages", "mergedInput", "exec", "import_fs", "mergedInput", "getActionInput", "getGithubInput", "packageInfo", "getPackageInfo", "packageVersion", "getPackageVersion", "packageScope", "getPackageScope", "v", "installPackages", "lines", "createTag", "error"]
}
