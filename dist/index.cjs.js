"use strict";var G=Object.create;var l=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,$=Object.prototype.hasOwnProperty;var A=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of _(e))!$.call(t,i)&&i!==r&&l(t,i,{get:()=>e[i],enumerable:!(n=S(e,i))||n.enumerable});return t};var V=(t,e,r)=>(r=t!=null?G(v(t)):{},A(e||!t||!t.__esModule?l(r,"default",{value:t,enumerable:!0}):r,t));var o=require("@actions/core");var s=require("@actions/core"),f=()=>{let t=[],e=(0,s.getInput)("auth_token");if(e||t.push("auth_token"),t.length>0)throw new Error(`Missing input ${t.join(" ")}`);return{authToken:e,createTag:(0,s.getInput)("create_tag")==="true",projectBuildDir:(0,s.getInput)("project_build_dir")||"dist",registry:(0,s.getInput)("registry")||"https://registry.npmjs.org/",installBuildPackages:(0,s.getInput)("install_build_packages")==="true"}};var h=()=>{let t=[],{GITHUB_REF:e,GITHUB_SHA:r,GITHUB_REPOSITORY:n,GITHUB_TOKEN:i}=process.env;if(e||t.push("GITHUB_REF"),r||t.push("GITHUB_SHA"),n||t.push("GITHUB_REPOSITORY"),i||t.push("GITHUB_TOKEN"),t.length>0)throw new Error(`Missing env ${t.join(" ")}`);return{ref:e,sha:r,repository:n,token:i}};var a=require("@actions/github"),p=require("@actions/core"),k=async(t,e)=>{let r=(0,a.getOctokit)(t.token).rest.git;(0,p.debug)("Pushing new tag to the repo");let i=(await r.createTag({...a.context.repo,tag:e,message:`Released version ${e}`,object:t.sha,type:"commit"})).data.sha;(0,p.debug)("Pushing new tag to the repo"),await r.createRef({...a.context.repo,ref:`refs/tags/${e}`,sha:i})};var d=V(require("node-fetch")),I=require("path"),c=require("fs"),R=async(t,e={method:"GET"})=>await(await(0,d.default)(t,e)).json(),y=async t=>{let e=(0,I.join)(t.projectBuildDir,"package.json");if(!(0,c.existsSync)(e))throw new Error(`Missing package json in project build directory (${e}).`);return JSON.parse((0,c.readFileSync)(e).toString("utf8"))},P=async t=>{let e=await R(`https://registry.npmjs.org/${t.name}`).then(r=>r.versions||{}).then(r=>Object.keys(r));return{currentPackageVersion:t.version,publishedVersions:e}},b=t=>{let{name:e}=t;if(e.startsWith("@")){let r=e.indexOf("/",1);return r!==-1?e.slice(0,r):null}return null};var j=require("@actions/exec");var g=require("path"),u=require("fs"),m=require("@actions/core");var w=require("@actions/exec"),x=async t=>{let e="",r="";try{return{code:await(0,w.exec)(t,void 0,{listeners:{stdout:n=>{e+=n.toString()},stderr:n=>{r+=n.toString()}}}),stdout:e,stderr:r}}catch(n){throw new Error(`Error in command '${t}', ${n} `)}};var E=async t=>{if(t.installBuildPackages){if((0,u.existsSync)((0,g.join)(t.projectBuildDir,"package-lock.json"))){(0,m.info)("Skip: already installed via npm");return}if((0,u.existsSync)((0,g.join)(t.projectBuildDir,"yarn.lock"))){(0,m.info)("Skip: already installed via yarn");return}await x(`npm --prefix ${t.projectBuildDir} install --production`)}};var T=require("fs");(async()=>{try{let t={...f(),...h()},e=await y(t),r=await P(e),n=await b(e);if((0,o.setOutput)("currentVersion",r.currentPackageVersion),r.publishedVersions.find(B=>r.currentPackageVersion===B)){(0,o.info)(`Package already published ${r.currentPackageVersion}`),(0,o.setOutput)("published",!1);return}await E(t);let i=[`//${t.registry.replace(/^https?:\/\//,"")}:_authToken=${t.authToken}`,`_auth=${t.authToken}`,"email=bot@github-action-npm-publish.com","always-auth=true",`registry=${t.registry}`,,];n!==null&&`${n}${t.registry}`,(0,T.writeFileSync)("/home/runner/.npmrc",i.join(`
`)),await(0,j.exec)(`npm publish ${t.projectBuildDir} --access public`),(0,o.setOutput)("published",!0),t.createTag&&await k(t,r.currentPackageVersion)}catch(t){typeof t=="string"?(0,o.setFailed)(t):t instanceof Error&&(0,o.setFailed)(t)}})();
//# sourceMappingURL=index.cjs.js.map
